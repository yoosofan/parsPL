


.اگر تعداد خانه‌ها == ۱۲ 
    تعداد += ۱
.یااگر تعداد خانه‌ها == ۱۶
    تعداد +=۲
.وگرنه تعداد +=۳



بنویس()
بنویس(۲؛۳؛۴؛«یک رشته‌ی ثابت»)



متغیر۲ = بخوان(۳)

متغیر۱ = بخوان()
متغیر۱ = بخوان(«یک عدد وارد کنید »)



> ، < ، <= ، >= ، == ، != ، === 



کلمه کلیدی
Keyword
کلمه کلیدی
keyword
.یااگر
.elif
.اگر
.if
.تاهنگامیکه
.while
.وگرنه
.else
.تعریف
.def
.چرخه
.for
.هنگامیکه
.when
.گزینش
.select
.بشکن
.break
.بروبه
.goto
.بگذار
.set
.بگیر
.get



.مقدار
.value
.برگرد
.return
.نتیجه
.result
.ساختار
.struct
.عمومی
.public
.خصوصی
.private
.حفاظت
.protected
.داخلی
.internal
.پوچ
.null
.هیچ
.none
.درست
.true
.نادرست
.false
.صحیح
.int
.بلند
.long
.اعشار
.double
.نویسه
.char
.رشته
.string
.ادامه
.continue
.نوع
.type
.تابع
.function









رشته‌های ثابت با گیومه (در انگلیسی ”constant string” به کمک double quotation و در فارسی «رشته‌ی ثابت») نشان داده می‌شوند. علامت quotation  معمولی ' اکنون کاربردی ندارد. تصمیم گیری درباره‌ی علامت‌هایی همچون n\ و t\ دشوار است زیرا حرف یا کلمه‌های فارسی جایگزین آن‌ها شود و همچنین به دلیل از راست به چپ بودن باید میان \ و / تفاوت گذاشت.
برای رشته‌های ثابت چند خطی @:@ به همراه یک کلمه چسبیده به آن به کار برده می‌شود و پس از نویسه‌ی خط جدید رشته‌ی ثابت چند خطی است آغاز می‌شود. پایان رشته ثابت چند خطی نیز همان کلمه می‌آید که پس از آن @:@ و یک فاصله یا خط جدید گذاشته می‌شود.





رشته۱ = @:@رشتهثابت
هر چیزی می‌تواند
اینجا نوشته شود.
رشتهثابت@:@ 




.چرخه تعداد=۰ ؛ تعداد < ۵ ؛ تعداد++
  بنویس(تعداد)




فهرست۱= [۱ ؛ ۲ ؛ ۳ ؛ ۴ ]
.چرخه متغیری .در فهرست۱
   بنویس(متغیری)




تعداد = ۱
.چرخه ۱۲ {
	بنویس(تعداد) 
	تعداد += ۱
}
تعداد =۱
ط=۱۶
.چرخه ط {1
	بنویس(تعداد) 
	تعداد += ۱
}




.تاهنگامیکه متغیر۱ < ۱۲
   متغیر۱ += ۱ ؛ عدد۲ *= متغیر۱




.گزینش نام متغیر
	.هنگامیکه ۱۲ { کاری را انجام بده }
	.هنگامیکه «مقدار یک رشته»
		کار دیگری را انجام بده()
	.هنگامیکه .در [۲..۵]
    {
		کار سوم را انجام بده()
    } 
	.هنگامیکه .در [۲..۵::۰/۱] 
			کار چهارم را انجام بده()
	.وگرنه
		کار پیش‌فرض را انجام بده()



متغیر ارجاعی = & متغیر معمولی

متغیر ارجاعی ۲ = متغیر ارجاعی



متغیر۳ = * متغیر ارجاعی



آرایه۱[]=۱۲
آرایه۱[]=۱۴


آرایه۱[۱]=۱۲
آرایه۱[۲]=۱۴


آرایه۱=[۱۲؛۱۴]



می‌توان آرایه را به شکل زیر خالی کرد.
آرایه۱=[]

array1=[]
اگر به صورت زیر مقدار دهی انجام شود فقط یک عنصر درون آرایه گذاشته می‌شود که خود یک آرایه است.
آرایه۱[]=[۱۲؛۱۴]

array1[]=[12,14]
در این حالت آرایه۱ فقط یک خانه با نمایه‌ی (index) یک دارد که درون آن یک آرایه با دو عنصر گذاشته شده است. 
نمایه‌های آرایه می‌توانند هر نوعی باشند و در‌واقع به صورت نگاشت باشند. همچنین کروشه‌های درونی مفهوم آرایه‌های داخلی را دارند و با آرایه‌های چند بُعدی تفاوت دارند.
B1 = [ [2,4],[3,5],[6,15],[12.3,6] ]
آرایه‌ی بالا یک آرایه با ۴ عنصر است که هر عنصر آن آرایه‌ای با دو عنصر را در بردارد. 
B2[“ali”] = “reza”
B3[2,4]=5
آرایه‌هایی که مانند زبان C باشند به صورت زیر تعریف می‌شوند.
آرایه ۱[۱..۳::۱]=[۰؛۰؛۰]
آرایه ۱[..۳] = [۰]
آغاز = ۱
پایان = ۳
گام = ۱
یک عدد = ۰
آرایه۱[آغاز..پایان::گام] = [یک یا چند عدد یا بازه‌ی عدد]

A1[1..3:1] = [0,0,0] //  A1[1]=0.....A1[3]=0
A1[..3]=[0]   //  A1[1]=0  , A1[2]=0  , A1[3]=0
start=1;
end =3
step=1
val =0
A1[start..end:step]=[val]
مانند زبان C نیز می‌توان مقدارهایی را برای آن در نظر گرفت و آرایه را تعریف کرد. 
دو دستور زیر یک کار را انجام می‌دهند. خانه‌ی ۱ و ۱ از آرایه‌ی A1  برابر ۳ گذاشته شده است. و یک آرایه‌ی دو بُعدی تعریف شده است.
A1[1,1]=3
A1[,]=3
آرایه‌های چند بعدی در این زبان مانند دستور بالا به کار برده می‌شوند و به این ترتیب تعداد کمتری از علامت برای دسترسی به عنصرهای آن نیاز است. همچنین نیازی نیست که نمایه‌های آرایه‌های چند بعدی عددی باشند بلکه می‌توانند هر نوعی باشند. 
A1[“ali”,”reze”] = “hamid”

فهرست دوستان[«علی» ؛ «رضایی»] = «حمیدی»
همچنین یک آرایه یا فهرست از اشیاء (عدد، نویسه، رشته، …. ) را می‌توان به عنوان نمایه‌های یک آرایه معرفی کرد.
L1 = [“Ali”, “Reza”,”Parsa”, “Siavash”]
A1[L1]=0
A2[[“a”,”b”,0,5,-12,”Hamid”]]=0
// یک آرایه با نمایه‌های داده شده درون کروشه باز و بسته است که همگی مقدار اولیه‌ی صفر را می‌گیرند.

ف۱=[«علی»؛ «رضا» ؛ «پارسا» ؛ «سیاوش»]
آ۱[ف۱]= ۰
آ۲[[«ا» ؛ «ب» ؛ ۰ ؛ ۵ ؛ ۱۲- ؛ «حمید»] ] = ۰

می‌توان آرایه‌های چند بُعدی را نیز در آغاز تعریف کرد و مقدار دهی اولیه نمود. دو دستور زیر هر دو یک کار را انجام می‌دهند.
آرایه۱[۱..۳::۱ ؛ ۱..۴::۱]=[[۰؛۰؛۰]؛[۱؛۱؛۲؛۲؛۲؛۲]]
آرایه۱[..۳؛..۴] = [[۰]؛[۱؛۱؛۲]]
 5.17 . تابع‌های آماده
در این بخش تعدادی تابع‌های آماده زبان نوشته شده است. هنگام فراخوانی هر تابعی باید پرانتز باز به نام تابع چسبیده باشد و از آن سوا نباشد.
 5.17.1 . تابع‌های عمومی

نام تابع
Function name
نام تابع
Function name
طول
len
بنویس
print
اندازه
size
بخوان
input
سیستم
system
به رشته
str


از رشته
tstr
 5.17.2 . تابع‌های ریاضی
نام تابع
Function name
نام تابع
Function name

asin

sin

acos

cos

atg

tg

actg

ctg

asinh

sinh

acosh

cosh

atgh

tgh

actgh

ctgh

ln

log

round

truncate

ceil

floor
جذر
sqrt
قدر مطلق
abs


توان
pow
 5.17.3 . تابع‌های آماری
نام تابع
Function name
نام تابع
Function name
میانگین
avg
کوچکترین
min
انحراف معیار
stdv
بزرگترین
max
تصادفی
random
میانه
mode
 5.17.4 . تابع‌های عضو رشته

نام تابع
Function name
نام تابع
Function name
نمایه
index
زیر رشته
substr
شکستن
split
نمایه وارون
rindex
 5.17.5 . تابع‌های عضو آرایه‌ها
نام تابع
Function name
نام تابع
Function name
حذف
del
پیوند
join
افزودن
insert
اتصال
append
مرتب کلید
sortkey
مرتب
sort
جستجوی وارون
rfind
جستجو
find


جستجوی همه
afind
 5.18 . تابع
نوشتن تابع یکی از بخش‌های مهم هر زبان برنامه نویسی است. در این زبان نیز تابع  را می‌توان به سادگی به کمک کلمه‌ی کلیدی تابع (function) نوشت و آرگومان‌هایی را برای آن فرستاد. آرگومان‌ها و مقدار برگشتی تابع کپی می‌شوند مگر برای آن‌هایی که ارجاع برایشان گذاشته شده باشد. کلمه‌ی کلیدی برگرد (return) برای برگرداندن مقدار برگشتی تابع به کار می‌رود.
.تابع افزایش یک (عدد۱){
	.برگرد عدد‍۱ + ۱
} 
#
.تابع افزایش دو (عدد۱)
	.برگرد عدد۱ + ۲
#
.تابع نوشتن عددهای اول (تا عدد){
	.اگر تا عدد < ۲
		.برگرد
	عدد۱ = ۳
	بنویس(۲)
	.تا هنگامی‌که عدد۱ <= تا عدد {
		عدد ۲ = ۳
		پرچم۱ = .نادرست
		.تا هنگامی که عدد۲ <= جذر(عدد۱){
			.اگر عدد۱ % عدد ۲ == ۰{
				پرچم۱ = .درست			
				.بشکن
			}
			عدد۲+=۲
		}
		.اگر پرچم۱ == .نادرست
			بنویس(عدد۱)
		عدد۱ += ۲
	}
}
 5.19 . تبدیل به رشته
تابع رشته همه چیز را می‌تواند به رشته تبدیل کند. اگر درون یک شیء تابع رشته باز تعریف شده باشد از آن کمک می‌گیرد و گرنه یکایک عنصرهای شیء را به رشته تبدیل کرده و با فاصله کنار هم می‌گذارد. 
 5.20 . تبدیل از رشته
تابع «از رشته» یک رشته را می‌گیرد و به هر نوع دلخواهی تبدیل می‌کند. اگر تابع از رشته در یک شیء سربار گذاری شده باشد که همان تابع را به کار می‌برد و گرنه به طور خودکار می‌کوشد به کمک فاصله‌ها یکی یکی جزء‌ها را به دست آورده و تبدیل کند.
 5.21 . قانون بلاک‌ها
در این زبان مانند زبان C می‌توان برای دستورهایی که چندین خط را در بردارند آکولاد باز و بسته {} را به کار برد و برای آن‌هایی که یک خط را در بردارند نیازی به گذاشتن آکولاد باز و بسته نیست فقط باید به خط بعد برود. در اینجا مفهوم خط از مفهوم دستور جداست زیرا در یک خط می‌توان چندین دستور را گذاشت  که با ؛ (یا نویسه‌ی دیگر مانند نقطه«.» یا «\». در آینده یکی از این‌ها برگزیده خواهد شد. ) از هم جدا شده‌اند و در پایان خط نویسه یا نویسه‌های پایان خط گذاشته می‌شود. بنابراین برای چند دستوری که درون یک خط هستند و با ؛ از هم جدا شده‌اند نیازی نیست که آکولاد باز و بسته گذاشته شود.
حتی تابعی نیز که یک خطی است، می‌تواند بدون آکولاد باز و بسته باشد. 
برخلاف زبان python در این زبان نیازی نیست که تو رفتگی رعایت شود و بلاک به کمک تو رفتگی مشخص شود، پیشنهاد می‌شود همواره تورفتگی برای خوانایی بیشتر رعایت شود. همچنین محدودیت آن یک دستور بدون بلاک نیست بلکه یک خط است. بنابراین می‌توان همه‌ی برنامه را در یک خط نیز نوشت، گرچه پیشنهاد نمی‌شود.
 5.22 . پرونده‌ها
کار کردن با پرونده‌ها در این زبان (ParsPL) بسیار بسیار ساده است. چند گونه پرونده وجود دارد که هر کدام جداگانه توضیح داده می‌شوند.
 5.22.1 . پرونده‌های متنی ساده
این پرونده‌ها با کدگذاری یونی‌کد با طول متغیر (utf-8) هستند. به این ترتیب که با باز کردن پرونده به سادگی می‌توان خط‌های درون آن را تغییر داد یا اینکه خطی را همانند کار با آرایه از آن خواند.
پرونده۱ = باز کن(«نام پرونده»)
پرونده۱[۱]= «سلام»
پرونده۱[۲]= «حال شما چطوره ؟»
پرونده۱[۳] = «امیدوارم تندرست باشید.»
پرونده۱[۴] = «خدانگهدار»
بنویس(پرونده۱[۲])
@{ خروجی به صورت زیر خواهد بود 
  حال شما چطوره ؟
}@
پرونده ۱.ببند()
به طور خودکار در پایان خط‌ها نویسه (یا نویسه‌های) پایان خط گذاشته می‌شود و نیازی نیست این نویسه‌ها گذاشته شود. هنگامی که تابع پایان می‌پذیرد یا اینکه برنامه پایان می‌پذیرد پرونده به طور خودکار بسته می‌شود. اگر درون متغیری که در بردارنده‌ی پرونده است چیزی دیگری گذاشته شود نیز پرونده به طور خودکار بسته می‌شود. 
در هر جایی از پرونده می‌توان نوشت و بنابراین محدود به طولی که اکنون دارد نیست. برای خط‌های خالی فقط نویسه خط بعد گذاشته می‌شود. ولی برای خواندن از پرونده اگر بخواهد به خطی دسترسی پیدا کندکه جزء آن نیست آن‌گاه خطا می‌دهد. این خطا می‌تواند به صورت برگردان مقدار «پوچ» باشد یا اینکه یک استثناء رخ دهد. هنوز درباره‌ی اینکه کدام گزینه پیش‌فرض باشد تصمیم نگرفته‌ام.
هنگام نوشتن به طور خودکار نویسه‌های پایان خط افزوده می‌شوند و هنگام خواندن نویسه‌های پایان خط به طور خودکار برداشته می‌شوند و برنامه نویس نگران آن‌ها نخواهد بود.
برای اینکه بتوان به نویسه‌ی ویژه‌ای از یک خط نیز دسترسی پیدا کرد کار بسیار ساده است
بنویس(پرونده۱[۲،۱])
دستور بالا «ل» را چاپ می‌کند.
برای دسترسی به خط‌ها می‌تواند دستور .چرخه را نیز به کار برد که به این ترتیب به سادگی خط‌ها را برمی‌گرداند. البته نمی‌تواند خط‌ها را در این حالت تغییر داد.
.چرخه  خط  .در باز کن(«نام پرونده»)
    بنویس(خط)
 5.22.2 . پرونده‌های دودویی ساده
در این زبان پرونده‌های دودویی ساده حالت ویژه‌ای از پرونده‌های دودویی هستند که مانند یک آرایه می‌توان با آن‌ها رفتار کرد و هر گونه نوعی را می‌توان درون آن‌ها گذاشت یا از درون آن‌ها حذف کرد. در‌واقع همه‌ی کارهایی که نیاز است که پرونده مانند یک آرایه رفتار کند در پشت صحنه انجام می‌شود و الگوریتم‌های ذخیره و بازیابی در آن به کار برده می‌شود تا به سادگی کاربر بتواند با آن کار کند.
پرونده۱=باز کن(«نام پرونده»،«د»)
پرونده۱[۱]= ۱۲
پرونده۱[۲]= «سلام حال شما چطوره»
پرونده۱[۳] = متغیر از هر نوعی
.چرخه متغیری .در پرونده۱
     بنویس(متغیری)
همانند کار کردن با یک آرایه می‌توان با این پرونده‌ها کار کرد. در بخشی از پرونده نمایه‌ها گذاشته می‌شود. همانند پایگاه‌های داده پرونده از همان آغاز نیز دربردارنده‌ی اندازه‌ای خواهد بود. اگر پرونده دربردانده‌ی 
 5.23 . بررسی layout صفحه‌کلید فارسی در سیستم عامل‌های گوناگون
برای اینکه بتوان علامت‌هایی را در زبان به کار برد که به سادگی کاربر بتواند در سیستم عامل‌های گوناگون آن‌ها را به کار ببرد layout صفحه‌کلید فارسی در سیستم عامل‌های گوناگون بررسی شد. دقت شود که مهم‌ترین نویسه‌ها آن‌هایی هستند که به سادگی بتوان آن‌ها را در صفحه‌کلید زد و همچنین در سیستم عامل‌های گوناگون مکان یکسان و مناسبی داشته باشند و اگر میان انگلیسی و فارسی مشترک هم باشند بسیار بهتر است. برای نمونه نقطه (.) یکی از نویسه‌های مهم است. به همین دلیل چند کار برعهده‌ی آن گذاشته شد که در ادامه توضیح داده می‌شود.
















/*


آرایه۱ [۳] = ۴
بنویس(آرایه۱[۳])
شمارنده = ۱
.تا شمارنده < ۱۰{
	آرایه۱ [شمارنده] = شمارنده + آرایه۱[۳]
	بنویس(آرایه۱ [شمارنده])
	شمارنده = شمارنده + ۱
}
بنویس(شمارنده)
بنویس(آرایه۱[۵])


علی رضا = ۴
بنویس (علی رضا)
علی رضا =  علی رضا + حمید()
بنویس (علی رضا)
.تابع حمید(){
بنویس(«سیمنبتسمی»)
.برگرد ۳
}
.تابع سینا(رضا){
بنویس(رضا)
}
سینا(۴2)


رضا = بخوان(«رضا»)

بنویس (رضا)

.تابع کوروش ( حسین؛ سیب){
بنویس(حسین)
بنویس(سیب)
}
کوروش(۴؛۳)




کاظم = «jklhkjh»
بنویس( کاظم)
علی رضا = ۴
علی رضا = علی رضا \ ( علی رضا - 10)
بنویس (علی رضا)

.اگر علی رضا < ۱۰ 
	علی رضا =۸
.اگر علی رضا < ۰
پایان()
بنویس( علی رضا)

.اگر علی رضا > ۱۰  
	علی رضا =12
.وگرنه 
بنویس( کاظم)
بنویس (علی رضا)

	علی رضا =2


.تا علی رضا < ۱۰ {
	علی رضا = علی رضا + ۱
بنویس( علی رضا)
}
بنویس( علی رضا)

	علی رضا =5

.تا علی رضا < ۱۰ {

	علی رضا = علی رضا + ۱


بنویس( علی رضا)
}
بنویس( علی رضا)

علی رضا =۶
.تا علی رضا < ۱۰ 
	علی رضا = علی رضا + ۱

بنویس( کاظم)
 


بنویس (علی رضا)




بنویس (رضا)
علی رضا = 4 + بنویس(5)
بنویس( «علی رضا » ؛ علی رضا)

بنویس (رضا)
علی رضا = 4 + بنویس(5)

بنویس( «علی رضا » ؛ علی رضا)




